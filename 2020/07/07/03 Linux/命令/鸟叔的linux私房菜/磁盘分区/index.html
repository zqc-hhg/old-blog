<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>
        Max&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-reply replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            03 Linux/命令/鸟叔的linux私房菜/磁盘分区
        </p>
        <hr>
    </div>
    <div class="post-content">
        <blockquote>
<p>早期磁盘第一个扇区里面含有的重要信息我们称为MBR （Master Boot Record） 格式，但是由于近年来磁盘的容量不断扩大，造成读写上的一些困扰， 甚至有些大于 2TB 以上的磁盘分区已经让某些操作系统无法存取。因此后来又多了一个新的磁盘分区格式，称为 GPT （GUID partition table）</p>
</blockquote>
<p><img src="http://shouce.jb51.net/vbird-linux-basic-4/img/Disktructure.jpg" alt=""></p>
<h2 id="MSDOS-（MBR）-分区表格式与限制"><a href="#MSDOS-（MBR）-分区表格式与限制" class="headerlink" title="MSDOS （MBR） 分区表格式与限制"></a>MSDOS （MBR） 分区表格式与限制</h2><p>早期的 Linux 系统为了相容于 Windows 的磁盘，因此使用的是支持 Windows 的 MBR（Master Boot Record, 主要开机纪录区） 的方式来处理开机管理程序与分区表.</p>
<p>MSDOS第一个扇区 512Bytes 会有这两个数据：</p>
<ul>
<li>主要开机记录区（Master Boot Record, MBR）：可以安装开机管理程序的地方，有446 Bytes</li>
<li>分区表（partition table）：记录整颗硬盘分区的状态，有64 Bytes</li>
</ul>
<p><img src="http://shouce.jb51.net/vbird-linux-basic-4/img/partition-1.png" alt=""></p>
<p>由于分区表就只有64 Bytes而已，最多只能容纳四笔分区的记录， 这四个分区的记录被称为主要（Primary）或延伸（Extended）分区。 </p>
<p><strong>优点</strong>：</p>
<ol>
<li>数据的安全性： 因为每个分区的数据是分开的！所以，当你需要将某个分区的数据重整时，例如你要将计算机中Windows的C 盘重新安装一次系统时， 可以将其他重要数据移动到其他分区，例如将邮件、桌面数据移动到D 盘去，那么C 盘重灌系统并不会影响到D 盘！ 所以善用分区，可以让你的数据更安全。</li>
<li>系统的性能考虑： 由于分区将数据集中在某个柱面的区段，例如上图当中第一个分区位于柱面号码1~100号，如此一来当有数据要读取自该分区时， 磁盘只会搜寻前面1~100的柱面范围，由于数据集中了，将有助于数据读取的速度与性能。</li>
</ol>
<p><strong>延伸分区</strong></p>
<p><img src="http://shouce.jb51.net/vbird-linux-basic-4/img/partition-2.png" alt=""></p>
<p>上图当中，我们知道硬盘的四个分区记录区仅使用到两个，P1为主要分区，而P2则为延伸分区。请注意， 延伸分区的目的是使用额外的扇区来记录分区信息，延伸分区本身并不能被拿来格式化。 然后我们可以通过延伸分区所指向的那个区块继续作分区的记录。</p>
<p>MBR 主要分区、延伸分区与逻辑分区的特性作个简单的定义：</p>
<ul>
<li>主要分区与延伸分区最多可以有四笔（硬盘的限制）</li>
<li>延伸分区最多只能有一个（操作系统的限制）</li>
<li>逻辑分区是由延伸分区持续切割出来的分区；</li>
<li>能够被格式化后，作为数据存取的分区为主要分区与逻辑分区。延伸分区无法格式化；</li>
<li>逻辑分区的数量依操作系统而不同，在Linux系统中SATA硬盘已经可以突破63个以上的分区限制；</li>
</ul>
<p><strong>限制</strong>:</p>
<p>​        由于每组分区表仅有 16Bytes 而已，因此可纪录的信息真的是相当有限的！ 所以，在过去 MBR 分区表的限制中经常可以发现如下的问题：</p>
<ul>
<li>操作系统无法抓取到 2.2T 以上的磁盘容量！</li>
<li>MBR 仅有一个区块，若被破坏后，经常无法或很难救援。</li>
<li>MBR 内的存放开机管理程序的区块仅 446Bytes，无法容纳较多的程序码。</li>
</ul>
<h2 id="GPT-磁盘分区表"><a href="#GPT-磁盘分区表" class="headerlink" title="GPT 磁盘分区表"></a>GPT 磁盘分区表</h2><p>与 MBR 仅使用第一个 512Bytes 区块来纪录不同， GPT 使用了 34 个 LBA 区块来纪录分区信息。同时与过去 MBR 仅有一的区块，被干掉就死光光的情况不同， GPT 除了前面 34 个 LBA 之外，整个磁盘的最后 33 个 LBA 也拿来作为另一个备份。</p>
<p><img src="http://shouce.jb51.net/vbird-linux-basic-4/img/gpt_partition_1.jpg" alt=""></p>
<p>上述图示的解释说明如下：</p>
<ul>
<li><p>LBA0 （MBR 相容区块）</p>
<p>与 MBR 模式相似的，这个相容区块也分为两个部份，一个就是跟之前 446 Bytes 相似的区块，储存了第一阶段的开机管理程序！ 而在原本的分区表的纪录区内，这个相容模式仅放入一个特殊标志的分区，用来表示此磁盘为 GPT 格式之意。而不懂 GPT 分区表的磁盘管理程序， 就不会认识这颗磁盘，除非用户有特别要求要处理这颗磁盘，否则该管理软件不能修改此分区信息，进一步保护了此磁盘.</p>
</li>
<li><p>LBA1 （GPT 表头纪录）</p>
<p>这个部份纪录了分区表本身的位置与大小，同时纪录了备份用的 GPT 分区 （就是前面谈到的在最后 34 个 LBA 区块） 放置的位置， 同时放置了分区表的检验机制码 （CRC32），操作系统可以根据这个检验码来判断 GPT 是否正确。若有错误，还可以通过这个纪录区来取得备份的 GPT（磁盘最后的那个备份区块） 来恢复 GPT 的正常运.！</p>
</li>
<li><p>LBA2-33 （实际纪录分区信息处）</p>
<p>从 LBA2 区块开始，每个 LBA 都可以纪录 4 笔分区纪录，所以在默认的情况下，总共可以有 4*32 = 128 笔分区纪录喔！因为每个 LBA 有 512Bytes，因此每笔纪录用到 128 Bytes 的空间，除了每笔纪录所需要的识别码与相关的纪录之外，GPT 在每笔纪录中分别提供了 64bits 来记载开始/结束的扇区号码，因此，GPT 分区表对於单一分区来说， 他的最大容量限制就会在“ 264 <em> 512Bytes = 263 </em>1KBytes = 233*TB = 8 ZB ”，(1ZB = 230TB) .</p>
</li>
</ul>
<p><strong>限制</strong>：并不是所有的操作系统都可以读取到 GPT 的磁盘分区格式喔！同时，也不是所有的硬件都可以支持 GPT 格式。是否能够读写 GPT 格式又与开机的检测程序有关。</p>
<p>为解决这个问题，需要使用一个驱动——UEFI</p>
<h2 id="BIOS-搭配-MBR-GPT-的开机流程"><a href="#BIOS-搭配-MBR-GPT-的开机流程" class="headerlink" title="BIOS 搭配 MBR/GPT 的开机流程"></a>BIOS 搭配 MBR/GPT 的开机流程</h2><p>整个开机流程到操作系统之前的动作应该是这样的：</p>
<ol>
<li>BIOS：开机主动执行的固件，会认识第一个可开机的设备；</li>
<li>MBR：第一个可开机设备的第一个扇区内的主要开机记录区块，内含开机管理程序；</li>
<li>开机管理程序（boot loader）：一支可读取核心文件来执行的软件；</li>
<li>核心文件：开始操作系统的功能…</li>
</ol>
<p><strong>Boot loader</strong></p>
<p>Boot loader则是操作系统安装在MBR上面的一套软件。由于MBR仅有446 Bytes而已，因此这个开机管理程序是非常小而美的。 这个boot loader的主要任务有下面这些项目：</p>
<ul>
<li>提供菜单：使用者可以选择不同的开机项目，这也是多重开机的重要功能！</li>
<li>载入核心文件：直接指向可开机的程序区段来开始操作系统；</li>
<li>转交其他loader：将开机管理功能转交给其他loader负责。</li>
</ul>
<p>开机管理程序除了可以安装在MBR之外， 还可以安装在每个分区的开机扇区（boot sector）,这个特色才能造就“多重开机”的功能.</p>
<p>举一个例子来说，假设你的个人计算机只有一个硬盘，里面切成四个分区，其中第一、二分区分别安装了Windows及Linux， 你要如何在开机的时候选择用Windows还是Linux开机呢？假设MBR内安装的是可同时认识Windows/Linux操作系统的开机管理程序， 那么整个流程可以图示如下：</p>
<p><img src="http://shouce.jb51.net/vbird-linux-basic-4/img/loader.gif" alt="开机管理程序的工作执行示意图"></p>
<p>​        MBR的开机管理程序提供两个菜单，菜单一（M1）可以直接载入Windows的核心文件来开机； 菜单二（M2）则是将开机管理工作交给第二个分区的开机扇区（boot sector）。当使用者在开机的时候选择菜单二时， 那么整个开机管理工作就会交给第二分区的开机管理程序了。 当第二个开机管理程序启动后，该开机管理程序内（上图中）仅有一个开机菜单，因此就能够使用Linux的核心文件来开机啰。 这就是多重开机的工作情况.</p>
<h3 id="UEFI-BIOS-搭配-GPT-开机的流程"><a href="#UEFI-BIOS-搭配-GPT-开机的流程" class="headerlink" title="UEFI BIOS 搭配 GPT 开机的流程"></a>UEFI BIOS 搭配 GPT 开机的流程</h3><p>​        GPT 可以提供到 64bit 的寻址,BIOS 仅为 16 位的程序,两者不相容, 为了解决这个问题，因此就有了 UEFI （Unified Extensible Firmware Interface） 这个统一可延伸固件界面的产生。</p>
<p>​        与传统的 BIOS 不同，UEFI 简直就像是一个低阶的操作系统～甚至于连主板上面的硬件资源的管理， 也跟操作系统相当类似，只需要载入驱动程序即可控制操作。同时由于程控得宜，一般来说，使用 UEFI 接口的主机，在开机的速度上要比 BIOS 来的快上许多。</p>
<p>限制：</p>
<ul>
<li>UEFI 当初在发展的时候，就制定一些控制在里头，包括硬件资源的管理使用轮询 （polling） 的方式来管理，与 BIOS 直接了解 CPU 以中断的方式来管理比较， 这种 polling 的效率是稍微慢一些的，另外，UEFI 并不能提供完整的高速缓存功能，因此执行效率也没有办法提升。</li>
<li>由于过去 cracker 经常借由 BIOS 开机阶段来破坏系统，并取得系统的控制权，因此 UEFI 加入了一个所谓的安全启动 （secure boot） 机制， 这个机制代表着即将开机的操作系统必须要被 UEFI 所验证，否则就无法顺利开机。微软用了很多这样的机制来管理硬件。 不过加入这个机制后，许多的操作系统，包括 Linux ，就很有可能无法顺利开机。</li>
</ul>
<p>作用：</p>
<pre><code>     UEFI 大多用来作为启动操作系统之前的硬件检测、开机管理、软件设置等目的，基本上是比较难的。 同时，当载入操作系统后，一般来说，UEFI 就会停止工作，并将系统交给操作系统，这与早期的 BIOS 差异不大。比较特别的是，某些特定的环境下， 这些 UEFI 程序是可以部份继续执行的，以协助某些操作系统无法找到特定设备时，该设备还是可以持续运行。
</code></pre>
    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <p>Copyright © 2020 <a class="flink" href="https://hexo.io" target="_blank" rel="noopener">Hexo</a>-<a class="flink" href="https://github.com/sanjinhub/hexo-theme-geek" target="_blank" rel="noopener">Geek</a>.
        <label class="el-switch el-switch-green el-switch-sm" style="vertical-align: sub;">
            <input type="checkbox" name="switch" id="update_style">
            <span class="el-switch-style"></span>
        </label>
<!--         <script type="text/javascript">
        var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
        document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
        </script> -->
    </p>
</div>
<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="SPu2VRL8GBwy0tz4XPGRVVM8-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="wmFJLexGHhIBOmhlio1SFhCt">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
    color: #698fca;
}

.v .vlist .vcard .vhead .vsys {
    color: #3a3e4a;
}

.v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
}

.v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
}

.v a {
    color: #8696b1;
}

.v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
}
</style>
</body>

</html>